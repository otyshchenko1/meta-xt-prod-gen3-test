From a005efb135715c63785cbe4ec6e77399bf4e1bbe Mon Sep 17 00:00:00 2001
From: Oleksandr Tyshchenko <oleksandr_tyshchenko@epam.com>
Date: Mon, 4 Nov 2019 13:18:17 +0200
Subject: [PATCH 2/2] kernel-module-vspm: Do not control device's PM

All related clocks are controlled by DomD, so do not touch them here.

Signed-off-by: Oleksandr Tyshchenko <oleksandr_tyshchenko@epam.com>
---
 .../kernel-module-vspm/kernel-module-vspm.bb       |   4 +-
 .../0001-Do-not-control-device-s-PM.patch          | 257 +++++++++++++++++++++
 2 files changed, 260 insertions(+), 1 deletion(-)
 create mode 100644 meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm/0001-Do-not-control-device-s-PM.patch

diff --git a/meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm.bb b/meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm.bb
index 9b72361..3940c9b 100644
--- a/meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm.bb
+++ b/meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm.bb
@@ -18,7 +18,9 @@ VSPM_DRV_URL = "git://github.com/renesas-rcar/vspm_drv.git"
 BRANCH = "rcar_gen3"
 SRCREV = "7f854a9a1c4760255a54b7c14891d1545ed1bf43"
 
-SRC_URI = "${VSPM_DRV_URL};branch=${BRANCH}"
+SRC_URI = "${VSPM_DRV_URL};branch=${BRANCH} \
+    file://0001-Do-not-control-device-s-PM.patch \
+"
 
 # Fix patch for upscaling issue
 SRC_URI_append = " \
diff --git a/meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm/0001-Do-not-control-device-s-PM.patch b/meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm/0001-Do-not-control-device-s-PM.patch
new file mode 100644
index 0000000..c0708cd
--- /dev/null
+++ b/meta-rcar-gen3/recipes-kernel/kernel-module-vspm/kernel-module-vspm/0001-Do-not-control-device-s-PM.patch
@@ -0,0 +1,257 @@
+From 68e78a8800f30ad7e52a8848ee7c6e4751a1eff7 Mon Sep 17 00:00:00 2001
+From: Oleksandr Tyshchenko <oleksandr_tyshchenko@epam.com>
+Date: Mon, 4 Nov 2019 15:24:22 +0200
+Subject: [PATCH] Do not control device's PM
+
+All related clocks are controlled by DomD, so do not touch them here.
+
+Signed-off-by: Oleksandr Tyshchenko <oleksandr_tyshchenko@epam.com>
+---
+ vspm-module/files/vspm/drv/fdp/fdp_drv.c | 15 +------
+ vspm-module/files/vspm/drv/vsp/vsp_drv.c | 15 +------
+ vspm-module/files/vspm/drv/vspm_main.c   | 72 +-------------------------------
+ 3 files changed, 4 insertions(+), 98 deletions(-)
+
+diff --git a/vspm-module/files/vspm/drv/fdp/fdp_drv.c b/vspm-module/files/vspm/drv/fdp/fdp_drv.c
+index c61bbea..d504aa7 100644
+--- a/vspm-module/files/vspm/drv/fdp/fdp_drv.c
++++ b/vspm-module/files/vspm/drv/fdp/fdp_drv.c
+@@ -154,15 +154,10 @@ long fdp_lib_open(struct fdp_obj_t *obj)
+ 	if (ercd)
+ 		goto err_exit1;
+ 
+-	/* enable clock */
+-	ercd = fdp_ins_enable_clock(obj);
+-	if (ercd)
+-		goto err_exit1;
+-
+ 	/* initialize register */
+ 	ercd = fdp_ins_init_reg(obj);
+ 	if (ercd)
+-		goto err_exit2;
++		goto err_exit1;
+ 
+ 	/* registory interrupt handler */
+ 	ercd = fdp_reg_inth(obj);
+@@ -177,9 +172,6 @@ long fdp_lib_open(struct fdp_obj_t *obj)
+ err_exit3:
+ 	(void)fdp_ins_quit_reg(obj);
+ 
+-err_exit2:
+-	(void)fdp_ins_disable_clock(obj);
+-
+ err_exit1:
+ 	return ercd;
+ }
+@@ -214,11 +206,6 @@ long fdp_lib_close(struct fdp_obj_t *obj)
+ 	if (ercd)
+ 		return ercd;
+ 
+-	/* disable clock */
+-	ercd = fdp_ins_disable_clock(obj);
+-	if (ercd)
+-		return ercd;
+-
+ 	/* update status */
+ 	obj->status = FDP_STAT_INIT;
+ 
+diff --git a/vspm-module/files/vspm/drv/vsp/vsp_drv.c b/vspm-module/files/vspm/drv/vsp/vsp_drv.c
+index 60d69d4..0673437 100644
+--- a/vspm-module/files/vspm/drv/vsp/vsp_drv.c
++++ b/vspm-module/files/vspm/drv/vsp/vsp_drv.c
+@@ -198,15 +198,10 @@ long vsp_lib_open(unsigned char ch, struct vsp_open_t *param)
+ 	if (ercd)
+ 		goto err_exit1;
+ 
+-	/* enable clock */
+-	ercd = vsp_ins_enable_clock(prv);
+-	if (ercd)
+-		goto err_exit1;
+-
+ 	/* initialize register */
+ 	ercd = vsp_ins_init_reg(prv);
+ 	if (ercd)
+-		goto err_exit2;
++		goto err_exit1;
+ 
+ 	/* registory interrupt handler */
+ 	ercd = vsp_ins_reg_ih(prv);
+@@ -222,9 +217,6 @@ long vsp_lib_open(unsigned char ch, struct vsp_open_t *param)
+ err_exit3:
+ 	(void)vsp_ins_quit_reg(prv);
+ 
+-err_exit2:
+-	(void)vsp_ins_disable_clock(prv);
+-
+ err_exit1:
+ 	return ercd;
+ }
+@@ -267,11 +259,6 @@ long vsp_lib_close(unsigned char ch)
+ 	if (ercd)
+ 		return ercd;
+ 
+-	/* disable clock */
+-	ercd = vsp_ins_disable_clock(prv);
+-	if (ercd)
+-		return ercd;
+-
+ 	/* update status */
+ 	prv->ch_info[0].status = VSP_STAT_INIT;
+ 	prv->ch_info[1].status = VSP_STAT_INIT;
+diff --git a/vspm-module/files/vspm/drv/vspm_main.c b/vspm-module/files/vspm/drv/vspm_main.c
+index 2e1f09c..44f30a0 100644
+--- a/vspm-module/files/vspm/drv/vspm_main.c
++++ b/vspm-module/files/vspm/drv/vspm_main.c
+@@ -295,8 +295,6 @@ static int vspm_vsp_probe(struct platform_device *pdev)
+ {
+ 	struct vspm_drvdata *pdrv = p_vspm_drvdata;
+ 	struct device_node *np = pdev->dev.of_node;
+-	char *clk_names[CLKNUM] = {VSP_CLK_NAME, FCP_CLK_NAME};
+-	struct clk *clk;
+ 
+ 	int i;
+ 	int ch;
+@@ -318,27 +316,12 @@ static int vspm_vsp_probe(struct platform_device *pdev)
+ 		return -1;
+ 	}
+ 
+-	/* set clocks */
+-	for (i = 0; i < CLKNUM; i++) {
+-		clk = devm_clk_get(&pdev->dev, clk_names[i]);
+-		if (IS_ERR(clk)) {
+-			APRINT("Cannot get %s clock!! ch=%d\n",
+-			       clk_names[i], ch);
+-			for (; i > 0; i--)
+-				pdrv->vsp_clks[ch][i - 1] = NULL;
+-			return -1;
+-		}
+-		pdrv->vsp_clks[ch][i] = clk;
+-	}
++	dev_info(&pdev->dev, "Device's PM is not controlled\n");
+ 
+ 	/* set driver data */
+ 	platform_set_drvdata(pdev, &pdrv->vsp_clks[ch]);
+ 	pdrv->vsp_pdev[ch] = pdev;
+ 
+-	/* set runtime PM */
+-	pm_suspend_ignore_children(&pdev->dev, true);
+-	pm_runtime_enable(&pdev->dev);
+-
+ 	return 0;
+ }
+ 
+@@ -350,9 +333,6 @@ static int vspm_vsp_remove(struct platform_device *pdev)
+ 	int i;
+ 	int ch;
+ 
+-	/* unset runtime PM */
+-	pm_runtime_disable(&pdev->dev);
+-
+ 	/* get channel */
+ 	of_property_read_u32(np, "renesas,#ch", &ch);
+ 
+@@ -360,10 +340,6 @@ static int vspm_vsp_remove(struct platform_device *pdev)
+ 	platform_set_drvdata(pdev, NULL);
+ 	pdrv->vsp_pdev[ch] = NULL;
+ 
+-	/* unset clocks */
+-	for (i = 0; i < CLKNUM; i++)
+-		pdrv->vsp_clks[ch][i] = NULL;
+-
+ 	return 0;
+ }
+ 
+@@ -371,8 +347,6 @@ static int vspm_fdp_probe(struct platform_device *pdev)
+ {
+ 	struct vspm_drvdata *pdrv = p_vspm_drvdata;
+ 	struct device_node *np = pdev->dev.of_node;
+-	char *clk_names[CLKNUM] = {FDP_CLK_NAME, FCP_CLK_NAME};
+-	struct clk *clk;
+ 
+ 	int i;
+ 	int ch;
+@@ -394,27 +368,12 @@ static int vspm_fdp_probe(struct platform_device *pdev)
+ 		return -1;
+ 	}
+ 
+-	/* set clocks */
+-	for (i = 0; i < CLKNUM; i++) {
+-		clk = devm_clk_get(&pdev->dev, clk_names[i]);
+-		if (IS_ERR(clk)) {
+-			APRINT("Cannot get %s clock!! ch=%d\n",
+-			       clk_names[i], ch);
+-			for (; i > 0; i--)
+-				pdrv->fdp_clks[ch][i - 1] = NULL;
+-			return -1;
+-		}
+-		pdrv->fdp_clks[ch][i] = clk;
+-	}
++	dev_info(&pdev->dev, "Device's PM is not controlled\n");
+ 
+ 	/* set driver data */
+ 	platform_set_drvdata(pdev, &pdrv->fdp_clks[ch]);
+ 	pdrv->fdp_pdev[ch] = pdev;
+ 
+-	/* set runtime PM */
+-	pm_suspend_ignore_children(&pdev->dev, true);
+-	pm_runtime_enable(&pdev->dev);
+-
+ 	return 0;
+ }
+ 
+@@ -426,9 +385,6 @@ static int vspm_fdp_remove(struct platform_device *pdev)
+ 	int i;
+ 	int ch;
+ 
+-	/* unset runtime PM */
+-	pm_runtime_disable(&pdev->dev);
+-
+ 	/* get channel */
+ 	of_property_read_u32(np, "renesas,#ch", &ch);
+ 
+@@ -436,10 +392,6 @@ static int vspm_fdp_remove(struct platform_device *pdev)
+ 	platform_set_drvdata(pdev, NULL);
+ 	pdrv->fdp_pdev[ch] = NULL;
+ 
+-	/* unset clocks */
+-	for (i = 0; i < CLKNUM; i++)
+-		pdrv->fdp_clks[ch][i] = NULL;
+-
+ 	return 0;
+ }
+ 
+@@ -477,31 +429,11 @@ static int vspm_pm_resume(struct device *dev)
+ 
+ static int vspm_pm_runtime_suspend(struct device *dev)
+ {
+-	struct platform_device *pdev = to_platform_device(dev);
+-	struct clk **clk = platform_get_drvdata(pdev);
+-
+-	int i;
+-
+-	for (i = 0; i < CLKNUM; i++) {
+-		if (clk[i])
+-			clk_disable_unprepare(clk[i]);
+-	}
+-
+ 	return 0;
+ }
+ 
+ static int vspm_pm_runtime_resume(struct device *dev)
+ {
+-	struct platform_device *pdev = to_platform_device(dev);
+-	struct clk **clk = platform_get_drvdata(pdev);
+-
+-	int i;
+-
+-	for (i = 0; i < CLKNUM; i++) {
+-		if (clk[i])
+-			clk_prepare_enable(clk[i]);
+-	}
+-
+ 	return 0;
+ }
+ 
+-- 
+2.7.4
+
-- 
2.7.4

